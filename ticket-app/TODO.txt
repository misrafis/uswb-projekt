1. Streszczenie Projektu
Projekt przedstawia architekturę i implementację skalowalnego, asynchronicznego systemu webowego przeznaczonego do sprzedaży biletów na wydarzenia. Głównym celem było stworzenie aplikacji odpornej na nagłe skoki ruchu (np. w momencie rozpoczęcia sprzedaży biletów na popularny koncert) oraz dostarczenie użytkownikowi transparentnej informacji o statusie jego zakupu, w tym o jego przybliżonej pozycji w kolejce.

System wykorzystuje nowoczesne wzorce architektoniczne, takie jak mikroserwisy, komunikacja asynchroniczna za pomocą brokera wiadomości oraz konteneryzację wszystkich komponentów.

2. Główne Funkcjonalności
Uwierzytelnianie i Autoryzacja: Pełna obsługa rejestracji i logowania użytkowników oparta na bezpiecznym hashowaniu haseł (Bcrypt) i tokenach JWT (JSON Web Tokens).
Asynchroniczny Zakup Biletów: Proces zakupu jest oddzielony od interakcji z użytkownikiem. Żądania są kolejkowane w RabbitMQ, co zapewnia wysoką dostępność i szybkość odpowiedzi API, niezależnie od aktualnego obciążenia.
Dynamiczne Śledzenie Statusu Zamówień: Dedykowana podstrona "Moje Zamówienia", która cyklicznie odpytuje API, aby na żywo wyświetlać status każdego zamówienia.
Wizualizacja Pozycji w Kolejce: System oblicza i wyświetla użytkownikowi jego pozycję startową oraz aktualny postęp przetwarzania kolejki.
Skalowalność Horyzontalna: Możliwość łatwego zwiększenia liczby "pracowników" (workerów) przetwarzających zamówienia w celu dynamicznego dostosowania przepustowości systemu do obciążenia.
Symulacja Wysokiego Ruchu: Dedykowany skrypt symulacja.py do testowania odporności systemu poprzez generowanie dziesiątek tysięcy jednoczesnych żądań zakupu.
Pełna Konteneryzacja: Wszystkie serwisy aplikacji są zamknięte w osobnych kontenerach i zarządzane przez jeden plik konfiguracyjny docker-compose.yml.
3. Architektura Systemu
Aplikacja składa się z kilku niezależnych, współpracujących ze sobą serwisów:

Frontend (Klient Webowy)

Rola: Interfejs użytkownika, z którym wchodzi w interakcję. Zbudowany jako wielostronicowa aplikacja (MPA).
Technologie: HTML, CSS, JavaScript.
Serwer: Nginx (działający jako serwer plików statycznych i Reverse Proxy).
Backend (API)

Rola: Publiczny punkt dostępowy aplikacji. Obsługuje żądania HTTP, zarządza logiką biznesową (rejestracja, logowanie), tworzy wstępne rekordy zamówień i działa jako Producent wiadomości dla RabbitMQ.
Technologie: Python, Flask, Flask-JWT-Extended, Flask-Bcrypt, Psycopg2, Pika.
Broker Wiadomości

Rola: Centralny system kolejkowy, który buforuje wszystkie żądania zakupu. Gwarantuje, że żadne żądanie nie zostanie utracone podczas dużego ruchu.
Technologia: RabbitMQ.
Worker (Konsument)

Rola: Niezależny proces działający w tle. Jego jedynym zadaniem jest pobieranie wiadomości z kolejki RabbitMQ i ich przetwarzanie (wykonywanie transakcji na bazie danych). Jest to komponent, który można skalować horyzontalnie.
Technologie: Python, Psycopg2, Pika.
Baza Danych

Rola: Trwały magazyn na wszystkie dane aplikacji: użytkowników, koncerty, zamówienia.
Technologia: PostgreSQL.
Schemat Przepływu Danych przy Zakupie:

Przeglądarka -> Nginx -> Backend API -> RabbitMQ -> Worker -> Baza Danych

4. Szczegółowy Opis Działania
Proces Zakupu Biletu
Użytkownik klika "Kup Bilet" na stronie frontendu.
Frontend wysyła żądanie POST /api/purchase z tokenem JWT w nagłówku.
Backend API odbiera żądanie, weryfikuje token. Następnie: a. Łączy się z RabbitMQ, aby sprawdzić aktualną długość kolejki. b. Tworzy w bazie PostgreSQL nowy rekord w tabeli orders ze statusem 'w kolejce' oraz zapisaną pozycją startową. c. Publikuje w kolejce RabbitMQ nową wiadomość, zawierającą m.in. order_id nowo utworzonego rekordu. d. Natychmiast odpowiada do frontendu, zwracając order_id i pozycję w kolejce.
Worker, który nasłuchuje na kolejce, pobiera wiadomość.
Worker wykonuje transakcję na bazie danych: sprawdza dostępność biletów w tabeli concerts, aktualizuje ich liczbę, a następnie zmienia status zamówienia w tabeli orders na 'zrealizowane' lub 'nieudane'.
Po pomyślnym zatwierdzeniu transakcji (commit), worker wysyła potwierdzenie (ack) do RabbitMQ, co trwale usuwa wiadomość z kolejki.
Proces Śledzenia Statusu
Użytkownik wchodzi na stronę "Moje Zamówienia".
JavaScript co 2 sekundy (setInterval) wysyła żądanie GET /api/my-orders.
Backend dla każdego zamówienia użytkownika o statusie 'w kolejce' wykonuje dodatkowe zapytanie do bazy, licząc, ile zamówień z niższym numerem startowym zostało już przetworzonych (COUNT(*)).
Na tej podstawie oblicza, ile osób jest jeszcze przed użytkownikiem w kolejce i zwraca tę informację w odpowiedzi JSON.
Frontend odbiera świeże dane i dynamicznie aktualizuje tabelę, dając użytkownikowi iluzję śledzenia na żywo.
5. Analiza Nierozwiązanego Problemu
Pod koniec projektu napotkaliśmy uporczywy problem, w którym strona "Moje Zamówienia" nie odświeżała dynamicznie liczby osób w kolejce, mimo że logi i testy poszczególnych komponentów wskazywały, że powinna.

Obserwacja: Frontend cyklicznie odpytuje API, ale dane wizualne w tabeli pozostają statyczne.
Diagnoza: Dogłębna analiza wykazała, że wszystkie komponenty (Frontend, Backend, Baza Danych, RabbitMQ) wydają się działać poprawnie w izolacji. Worker przetwarza wiadomości, a API zwraca dane. Najprawdopodobniej problem leży w subtelnym błędzie w logice workera, który mimo pobierania wiadomości, z nieznanej przyczyny nie zatwierdza (commit) zmian w bazie danych w sposób spójny. To powoduje, że API zawsze odczytuje ten sam, niezaaktualizowany stan z bazy. Rozwiązanie tego problemu wymagałoby dalszego, jeszcze bardziej szczegółowego logowania i debugowania samego workera.
6. Potencjał i Dalszy Rozwój
Stworzony projekt jest doskonałą bazą do dalszej rozbudowy o profesjonalne funkcjonalności:

Integracja z systemem płatności (np. Stripe).
Wysyłanie powiadomień e-mail do użytkowników po zakupie (z użyciem osobnej kolejki i workera).
Stworzenie panelu administratora do zarządzania koncertami.
Zastąpienie pollingu technologią WebSockets dla prawdziwie natychmiastowych aktualizacji.
Wprowadzenie testów automatycznych (jednostkowych i integracyjnych).